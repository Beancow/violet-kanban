#!/usr/bin/env node
// Lightweight validator for DEV_GUIDELINES rules.
// - Checks that `@/types` directory exists (src/types fallback)
// - Checks that there is a `src/stores` folder
// - Simple grep for `: any` or `as any` inside `src/services` which often indicates avoided guards
// Exit code 1 on validation failure.

const fs = require('fs');
const path = require('path');
const child = require('child_process');

function fail(msg) {
    console.error('✖', msg);
    process.exitCode = 1;
}

function ok(msg) {
    console.log('✔', msg);
}

const root = process.cwd();

// check types dir
const preferredTypes = path.join(root, 'src', 'types');
const altTypes = path.join(root, 'types');
if (fs.existsSync(preferredTypes) || fs.existsSync(altTypes)) {
    ok('types directory exists');
} else {
    fail('Missing types folder. Expected `src/types/` or top-level `types/`.');
}

// check stores dir
const storesDir = path.join(root, 'src', 'stores');
if (fs.existsSync(storesDir)) {
    ok('stores folder exists');
} else {
    fail(
        'Missing `src/stores` folder. Add class-based stores (QueueStore, SyncErrorStore, etc.).'
    );
}

// search for `as any` or `: any` in src/services
function grep(pattern, dir) {
    try {
        const out = child.execSync(
            `grep -RIn --exclude-dir=node_modules --exclude-dir=coverage -E "${pattern}" ${dir} || true`,
            { encoding: 'utf8' }
        );
        return out.trim().split('\n').filter(Boolean);
    } catch (e) {
        return [];
    }
}

const serviceDir = path.join(root, 'src', 'services');
if (fs.existsSync(serviceDir)) {
    const anyMatches = grep(': any|as any', serviceDir);
    if (anyMatches.length) {
        const strict = Boolean(process.env.VALIDATOR_STRICT_ANY);
        console.warn(
            '\u26a0 Found potential `any` usage in src/services (these should be replaced by type guards):'
        );
        anyMatches.slice(0, 20).forEach((l) => console.warn('  ', l));
        console.warn('...');
        if (strict) {
            fail('Explicit `any` usage found in src/services and VALIDATOR_STRICT_ANY=1');
        } else {
            // non-fatal warning
            process.exitCode = 2;
        }
    } else {
        ok('No blatant `any` usage found in src/services');
    }
} else {
    console.warn('No src/services dir found; skipping service checks');
}

// Check for files with multiple exports (except barrel files like index.ts)
function walkDir(dir, extensions = ['.ts', '.tsx', '.js', '.jsx']) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    let files = [];
    for (const e of entries) {
        const p = path.join(dir, e.name);
        if (e.isDirectory()) {
            if (
                ['node_modules', 'coverage', 'tests', '__mocks__'].includes(
                    e.name
                )
            )
                continue;
            files = files.concat(walkDir(p, extensions));
        } else if (e.isFile()) {
            const ext = path.extname(e.name).toLowerCase();
            if (extensions.includes(ext)) files.push(p);
        }
    }
    return files;
}

const srcRoot = path.join(root, 'src');
const multiExportFiles = [];
if (fs.existsSync(srcRoot)) {
    const allFiles = walkDir(srcRoot);
    // warn on files > 300 lines to encourage splitting large files
    const longFiles = [];
    for (const f of allFiles) {
        try {
            const txt = fs.readFileSync(f, 'utf8');
            const lines = txt.split(/\r?\n/).length;
            if (lines > 300) longFiles.push({ path: f, lines });
        } catch (e) {}
    }
    if (longFiles.length) {
        console.warn('\u26a0 Files longer than 300 lines detected (consider splitting):');
        longFiles.slice(0, 20).forEach((l) =>
            console.warn('  -', path.relative(root, l.path), `(${l.lines} lines)`)
        );
        process.exitCode = 2;
    }
    for (const f of allFiles) {
        const base = path.basename(f).toLowerCase();
        // allow barrel files named index.*
        if (base.startsWith('index.')) continue;
        try {
            const txt = fs.readFileSync(f, 'utf8');
            const matches = txt.match(/^\s*export\b/gm) || [];
            if (matches.length > 1) {
                multiExportFiles.push({ path: f, exports: matches.length });
            }
        } catch (e) {
            /* ignore unreadable files */
        }
    }
    if (multiExportFiles.length) {
        console.error(
            '✖ Files with multiple exports (split single-responsibility handlers into separate files):'
        );
        multiExportFiles
            .slice(0, 50)
            .forEach((m) =>
                console.error(
                    '  -',
                    path.relative(root, m.path),
                    `(${m.exports} exports)`
                )
            );
        console.error(
            'Note: barrel files named `index.*` are allowed to re-export multiple symbols.'
        );
        process.exitCode = 1;
    } else {
        ok('No files with multiple exports detected (non-barrel)');
    }
} else {
    console.warn('No src/ directory found; skipping multi-export checks');
}

// Check for minimal guard exports in src/types/typeGuards.ts
const typeGuardsPath = path.join(root, 'src', 'types', 'typeGuards.ts');
if (fs.existsSync(typeGuardsPath)) {
    try {
        const txt = fs.readFileSync(typeGuardsPath, 'utf8');
        const needs = ['isObject', 'isActionLike', 'hasOrganizationId'];
        const missing = needs.filter((n) => !new RegExp(`export\s+(const|function)\s+${n}`,'m').test(txt));
        if (missing.length) {
            console.warn('\u26a0 typeGuards missing expected guards:', missing.join(', '));
            process.exitCode = 2;
        } else {
            ok('typeGuards exports look reasonable');
        }
    } catch (e) {
        /* ignore */
    }
} else {
    console.warn('typeGuards not found; add src/types/typeGuards.ts');
}

// Required files (per DEV_GUIDELINES). These files may not exist yet; the
// validator will fail if they are missing so the TODOs are visible in CI.
const requiredFiles = [
    'DEV_GUIDELINES.md',
    'src/types/queue.ts',
    'src/types/syncError.ts',
    'src/types/typeGuards.ts',
    'src/stores/queues/boardQueueDB/boardQueueDB.ts',
    'src/stores/queues/listQueueDB/listQueueDB.ts',
    'src/stores/queues/cardQueueDB/cardQueueDB.ts',
    'src/stores/organizations/organizationsDB/organizationsDB.ts',
    'src/stores/organizationData/boardStoreDB/boardStoreDB.ts',
    'src/stores/organizationData/listStoreDB/listStoreDB.ts',
    'src/stores/organizationData/cardStoreDB/cardStoreDB.ts',
    'src/stores/ui/toastStoreDB/toastStoreDB.ts',
    'src/stores/ui/uiStoreDB/uiStoreDB.ts',
    'src/stores/errors/syncErrorDB/syncErrorDB.ts',
    'src/stores/TempIdMapStore.ts',
    'src/services/orchestration/OrchestratorService.ts',
    'src/services/orchestration/jobs/actionSuccess.ts',
    'src/services/orchestration/jobs/backoff.ts',
    'src/services/orchestration/jobs/buildAction.ts',
    'src/services/orchestration/jobs/pickNext.ts',
    'src/services/orchestration/jobs/postAndWait.ts',
    'src/services/orchestration/worker/workerOut/workerPoster.ts',
    'src/services/orchestration/worker/workerIn/workerMessages/handleSuccess.ts',
    'src/services/orchestration/worker/workerIn/workerMessages/handleError.ts',
    'src/services/orchestration/utils/inFlightManager.ts',
    'src/utils/eventBus.ts',
    'src/utils/eventBusClient.ts',
    // suggested additions
    'src/types/worker.ts',
    'src/types/handlers/index.ts',
    'src/stores/interfaces/Store.ts',
    'src/stores/adapters/inMemoryAdapter.ts',
    'src/utils/backoff.ts',
    'src/utils/leaderElection.ts',
    'docs/migration.md',
    'src/providers/shims/BoardProviderShim.tsx',
    'src/providers/shims/ListProviderShim.tsx',
    'src/providers/shims/CardProviderShim.tsx',
    'src/providers/shims/OrganizationProviderShim.tsx',
    'src/providers/shims/QueueProviderShim.tsx',
    'src/providers/shims/ToastProviderShim.tsx',
    'src/providers/shims/UiProviderShim.tsx',
    'src/providers/shims/SyncErrorProviderShim.tsx',
    'src/providers/shims/AuthProviderShim.tsx',
    'src/providers/shims/AppProviderShim.tsx',
];

let missingFiles = [];
for (const p of requiredFiles) {
    const abs = path.join(root, p);
    if (!fs.existsSync(abs)) missingFiles.push(p);
}

if (missingFiles.length) {
    console.error('✖ Missing required files per DEV_GUIDELINES:');
    missingFiles.forEach((f) => console.error('  -', f));
    // make this a failing condition so CI highlights missing implementations
    process.exitCode = 1;
} else {
    ok('All required files for DEV_GUIDELINES are present');
}

// Provider migration checks: find existing provider implementations and
// ensure a matching ProviderShim exists for each. This helps track where
// migration to stores/shims is still required.
const providersDir = path.join(root, 'src', 'providers');
const providerMigrationsNeeded = [];
if (fs.existsSync(providersDir)) {
    const files = fs.readdirSync(providersDir);
    for (const f of files) {
        const m = f.match(/^(.*Provider)\.(tsx?|ts)$/i);
        if (m) {
            const providerBase = m[1]; // e.g. BoardProvider
            const shimName = `${providerBase}Shim.ts`;
            const shimPath = path.join(providersDir, shimName);
            if (!fs.existsSync(shimPath)) {
                providerMigrationsNeeded.push(
                    path.join('src', 'providers', shimName)
                );
            }
        }
    }
    if (providerMigrationsNeeded.length) {
        console.error(
            '✖ Provider shims missing for the following providers (migration required):'
        );
        providerMigrationsNeeded.forEach((p) => console.error('  -', p));
        process.exitCode = 1;
    } else {
        ok('Provider shims exist for all detected providers');
    }
} else {
    console.warn('No providers directory found; skipping provider shim checks');
}

// Warn if there are helper files placed directly under src/stores/helpers
// or if store-specific helpers are not inside their DB folder.
const storeHelpersDir = path.join(root, 'src', 'stores', 'helpers');
if (fs.existsSync(storeHelpersDir)) {
    console.error(
        '✖ Found `src/stores/helpers` — move store-specific helpers into the relevant xStoreDB or xQueueDB folders'
    );
    process.exitCode = 1;
}

// Find any helper directories directly under src/stores that are not DB folders
const storeSubdirs = fs
    .readdirSync(path.join(root, 'src', 'stores'), { withFileTypes: true })
    .filter((d) => d.isDirectory())
    .map((d) => d.name);
for (const sub of storeSubdirs) {
    const subPath = path.join(root, 'src', 'stores', sub);
    // look for helper files directly inside this dir (not nested under *DB)
    const files = fs
        .readdirSync(subPath)
        .filter(
            (f) => f.endsWith('.ts') || f.endsWith('.tsx') || f.endsWith('.js')
        );
    if (
        files.length &&
        !sub.toLowerCase().includes('db') &&
        sub !== 'helpers'
    ) {
        // if this directory contains files and it's not a DB directory, warn
        console.warn(
            `⚠ Found top-level files in src/stores/${sub} — ensure store DB logic lives under a *DB folder (e.g. ${sub}StoreDB/)`
        );
        process.exitCode = 2;
    }
}

if (process.exitCode && process.exitCode !== 2) {
    console.error('Validation failed. See messages above.');
} else if (process.exitCode === 2) {
    console.warn('Validation completed with warnings (exit code 2)');
}
